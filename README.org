* Bootstrapping an auto scaling web application within AWS Kubernetes
  :PROPERTIES:
  :header-args: :results output verbatim  :cache yes :exports both
  :END:
 
Let's create a state-of-the-art deployment pipeline for cloud native applications. In this guide, I'll be using Kubernetes on AWS to bootstrap a load-balanced, static-files only web application. This is serious overkill for such an application, however this will showcase several necessities when designing such a system for more sophisticated applications.
This guide assumes you are using OSX. You also need to be familiar with both [[http://brew.sh/index.html][homebrew]] and AWS.
** About the tools
- [[http://kubernetes.io/][Kubernetes]] :: A Google-developed container cluster scheduler
- [[https://www.terraform.io/intro/getting-started/build.html][Terraform]]  :: A Hashicorp-developed infrastructure-as-code tool

** Getting to know Terraform
   To bootstrap Kubernetes, I will be using Kops. Kops internally uses Terraform to bootstrap a Kubernetes cluster.
First, I've made sure Terraform is up to date
#+BEGIN_SRC sh  
brew update
brew install terraform
#+END_SRC

#+RESULTS[fe6c2689e91e6d061c66b63dbc04577128b5eefd]:
: Already up-to-date.

To make sure my AWS credentials (saved in $HOME/.aws/credentials) were picked up by Terraform, I've created an initial, bare-bones Terraform config (which is pretty much taken verbatim from the [[https://www.terraform.io/intro/getting-started/build.html][Terraform Getting Started Guide]])
#+BEGIN_SRC terraform :tangle 1-initial/init.tf
provider "aws" {}

resource "aws_instance" "example" {
  ami           = "ami-0d729a60"
  instance_type = "t2.micro"
}
#+END_SRC
planned[fn:1] 
#+BEGIN_SRC sh
terraform plan 1-initial
#+END_SRC

#+RESULTS[e587d1b52e207580b608bcbe150acd2c44730415]:
#+begin_example
[0m[1mprovider.aws.region[0m
  The region where AWS operations will take place. Examples
  are us-east-1, us-west-2, etc.

  [1mDefault:[0m us-east-1
  [1mEnter a value:[0m [0m
Refreshing Terraform state in-memory prior to plan...
The refreshed state will be used to calculate this plan, but
will not be persisted to local or remote state storage.


The Terraform execution plan has been generated and is shown below.
Resources are shown in alphabetical order for quick scanning. Green resources
will be created (or destroyed and then created if an existing resource
exists), yellow resources are being changed in-place, and red resources
will be destroyed. Cyan entries are data sources to be read.

Note: You didn't specify an "-out" parameter to save this plan, so when
"apply" is called, Terraform can't guarantee this is what will execute.

[32m+ aws_instance.example
[0m    ami:                      "ami-0d729a60"
    availability_zone:        "<computed>"
    ebs_block_device.#:       "<computed>"
    ephemeral_block_device.#: "<computed>"
    instance_state:           "<computed>"
    instance_type:            "t2.micro"
    key_name:                 "<computed>"
    network_interface_id:     "<computed>"
    placement_group:          "<computed>"
    private_dns:              "<computed>"
    private_ip:               "<computed>"
    public_dns:               "<computed>"
    public_ip:                "<computed>"
    root_block_device.#:      "<computed>"
    security_groups.#:        "<computed>"
    source_dest_check:        "true"
    subnet_id:                "<computed>"
    tenancy:                  "<computed>"
    vpc_security_group_ids.#: "<computed>"
[0m
[0m
[0m[1mPlan:[0m 1 to add, 0 to change, 0 to destroy.[0m
#+end_example

and applied it
#+BEGIN_SRC sh
terraform apply 1-initial
#+END_SRC

#+RESULTS[7712e5563c62e780e4b29a71e78c646fd51dd78d]:
#+begin_example
[0m[1mprovider.aws.region[0m
  The region where AWS operations will take place. Examples
  are us-east-1, us-west-2, etc.

  [1mDefault:[0m us-east-1
  [1mEnter a value:[0m [0m
[0m[1maws_instance.example: Creating...[21m
  ami:                      "" => "ami-0d729a60"
  availability_zone:        "" => "<computed>"
  ebs_block_device.#:       "" => "<computed>"
  ephemeral_block_device.#: "" => "<computed>"
  instance_state:           "" => "<computed>"
  instance_type:            "" => "t2.micro"
  key_name:                 "" => "<computed>"
  network_interface_id:     "" => "<computed>"
  placement_group:          "" => "<computed>"
  private_dns:              "" => "<computed>"
  private_ip:               "" => "<computed>"
  public_dns:               "" => "<computed>"
  public_ip:                "" => "<computed>"
  root_block_device.#:      "" => "<computed>"
  security_groups.#:        "" => "<computed>"
  source_dest_check:        "" => "true"
  subnet_id:                "" => "<computed>"
  tenancy:                  "" => "<computed>"
  vpc_security_group_ids.#: "" => "<computed>"[0m
[0m[1maws_instance.example: Still creating... (10s elapsed)[21m[0m
[0m[1maws_instance.example: Still creating... (20s elapsed)[21m[0m
[0m[1maws_instance.example: Creation complete[21m[0m
[0m[1m[32m
Apply complete! Resources: 1 added, 0 changed, 0 destroyed.[0m
[0m
The state of your infrastructure has been saved to the path
below. This state is required to modify and destroy your
infrastructure, so keep it safe. To inspect the complete state
use the `Terraform show` command.

State path: Terraform.tfstate[0m
#+end_example

That looks promising, and with a quick glance at the AWS console I could confirm that Terraform had indeed boostrapped a t2.micro instance in the us-east-1. I destroyed it quickly afterwards to incur little to no costs via
#+BEGIN_SRC sh
terraform destroy -force 1-initial
#+END_SRC

#+RESULTS[7bd50d0841515b3685d28efe1f88969c17d6ac92]:
#+begin_example
[0m[1mprovider.aws.region[0m
  The region where AWS operations will take place. Examples
  are us-east-1, us-west-2, etc.

  [1mDefault:[0m us-east-1
  [1mEnter a value:[0m [0m
[0m[1maws_instance.example: Refreshing state... (ID: i-c7bc94f6)[0m
[0m[1maws_instance.example: Destroying...[21m[0m
[0m[1maws_instance.example: Still destroying... (10s elapsed)[21m[0m
[0m[1maws_instance.example: Still destroying... (20s elapsed)[21m[0m
[0m[1maws_instance.example: Still destroying... (30s elapsed)[21m[0m
[0m[1maws_instance.example: Destruction complete[21m[0m
[0m[1m[32m
Destroy complete! Resources: 1 destroyed.[0m
#+end_example

** Alright, Terraform looks good, let's get to work
Now that I have a basic understanding of Terraform, let's get to using it. As initially said, we are going to use Kops to bootstrap our cluster, so let's get it installed via the instructions found at [[https://github.com/kubernetes/kops][the project's GitHub repo]].
#+BEGIN_SRC sh
export GOPATH=$HOME/golang/
mkdir -p $GOPATH
go get -u -d k8s.io/kops
#+END_SRC
This timed out for me, several times. Running =go get= with =-u= allows you to rerun the same query again, hopefully without timing out.

Afterwards, I built the binary
#+BEGIN_SRC sh
cd ${GOPATH}/src/k8s.io/kops/
make
#+END_SRC


* Footnotes

[fn:1] Note that the output might look weird. I could not get emacs to work well with the escape characters Terraform uses to e.g. make its text bold.
